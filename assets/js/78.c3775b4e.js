(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{327:function(e,t,n){"use strict";n.r(t);var s=n(27),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"观察者模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[e._v("#")]),e._v(" 观察者模式")]),e._v(" "),n("p",[e._v("image")]),e._v(" "),n("p",[e._v("这就类似我们在微信平台订阅了公众号 , 当它有新的文章发表后，就会推送给我们所有订阅的人。")]),e._v(" "),n("p",[e._v("我们作为订阅者不必每次都去查看这个公众号有没有新文章发布，公众号作为发布者会在合适时间通知我们。")]),e._v(" "),n("p",[e._v("我们与公众号之间不再强耦合在一起。公众号不关心谁订阅了它， 不管你是男是女还是宠物狗，它只需要定时向所有订阅者发布消息即可。")]),e._v(" "),n("h1",{attrs:{id:"观察者模式的优点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式的优点"}},[e._v("#")]),e._v(" 观察者模式的优点")]),e._v(" "),n("p",[e._v("可以广泛应用于异步编程，它可以代替我们传统的回调函数\n我们不需要关注对象在异步执行阶段的内部状态，我们只关心事件完成的时间点\n取代对象之间硬编码通知机制，一个对象不必显式调用另一个对象的接口，而是松耦合的联系在一起 。\n虽然不知道彼此的细节，但不影响相互通信。更重要的是，其中一个对象改变不会影响另一个对象。")]),e._v(" "),n("h1",{attrs:{id:"nodejs的eventemitter"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nodejs的eventemitter"}},[e._v("#")]),e._v(" Nodejs的EventEmitter")]),e._v(" "),n("p",[e._v("Nodejs的EventEmitter就是观察者模式的典型实现，Nodejs的events模块只提供了一个对象： events.EventEmitter``。EventEmitter 的核心就是事件触发与事件监听器功能的封装。")]),e._v(" "),n("p",[e._v("Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。")]),e._v(" "),n("h1",{attrs:{id:"api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[e._v("#")]),e._v(" Api")]),e._v(" "),n("p",[e._v("addListener(event, listener)")]),e._v(" "),n("p",[e._v("为指定事件添加一个监听器，默认添加到监听器数组的尾部。")]),e._v(" "),n("p",[e._v("removeListener(event, listener)")]),e._v(" "),n("p",[e._v("移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。")]),e._v(" "),n("p",[e._v("setMaxListeners(n)")]),e._v(" "),n("p",[e._v("默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。")]),e._v(" "),n("p",[e._v("once(event, listener)")]),e._v(" "),n("p",[e._v("为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。")]),e._v(" "),n("p",[e._v("emit(event, [arg1], [arg2], [...])")]),e._v(" "),n("p",[e._v("按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。")]),e._v(" "),n("h1",{attrs:{id:"基本使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基本使用"}},[e._v("#")]),e._v(" 基本使用")]),e._v(" "),n("p",[e._v("var events = require('events');\nvar eventEmitter = new events.EventEmitter();")]),e._v(" "),n("p",[e._v("// 监听器 #1\nvar listener1 = function listener1() {\nconsole.log('监听器 listener1 执行。');\n}")]),e._v(" "),n("p",[e._v("// 监听器 #2\nvar listener2 = function listener2() {\nconsole.log('监听器 listener2 执行。');\n}")]),e._v(" "),n("p",[e._v("// 绑定 connection 事件，处理函数为 listener1\neventEmitter.addListener('connection', listener1);")]),e._v(" "),n("p",[e._v("// 绑定 connection 事件，调用一次，处理函数为 listener2\neventEmitter.once('connection', listener2);")]),e._v(" "),n("p",[e._v("// 处理 connection 事件\neventEmitter.emit('connection');")]),e._v(" "),n("p",[e._v("// 处理 connection 事件\neventEmitter.emit('connection');")]),e._v(" "),n("h1",{attrs:{id:"手动实现eventemitter"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#手动实现eventemitter"}},[e._v("#")]),e._v(" 手动实现EventEmitter")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("function EventEmitter() {\n  this._maxListeners = 10;\n  this._events = Object.create(null);\n}\n\n// 向事件队列添加事件\n// prepend为true表示向事件队列头部添加事件\nEventEmitter.prototype.addListener = function (type, listener, prepend) {\n  if (!this._events) {\n    this._events = Object.create(null);\n  }\n  if (this._events[type]) {\n    if (prepend) {\n      this._events[type].unshift(listener);\n    } else {\n      this._events[type].push(listener);\n    }\n  } else {\n    this._events[type] = [listener];\n  }\n};\n\n// 移除某个事件\nEventEmitter.prototype.removeListener = function (type, listener) {\n  if (Array.isArray(this._events[type])) {\n    if (!listener) {\n      delete this._events[type]\n    } else {\n      this._events[type] = this._events[type].filter(e => e !== listener && e.origin !== listener)\n    }\n  }\n};\n\n// 向事件队列添加事件，只执行一次\nEventEmitter.prototype.once = function (type, listener) {\n  const only = (...args) => {\n    listener.apply(this, args);\n    this.removeListener(type, listener);\n  }\n  only.origin = listener;\n  this.addListener(type, only);\n};\n\n// 执行某类事件\nEventEmitter.prototype.emit = function (type, ...args) {\n  if (Array.isArray(this._events[type])) {\n    this._events[type].forEach(fn => {\n      fn.apply(this, args);\n    });\n  }\n};\n\n// 设置最大事件监听个数\nEventEmitter.prototype.setMaxListeners = function (count) {\n  this.maxListeners = count;\n};\n")])])]),n("p",[e._v("测试代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("var emitter = new EventEmitter();\n\nvar onceListener = function (args) {\n  console.log('我只能被执行一次', args, this);\n}\n\nvar listener = function (args) {\n  console.log('我是一个listener', args, this);\n}\n\nemitter.once('click', onceListener);\nemitter.addListener('click', listener);\n\nemitter.emit('click', '参数');\nemitter.emit('click');\n\nemitter.removeListener('click', listener);\nemitter.emit('click');\n")])])]),n("h1",{attrs:{id:"javascript自定义事件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript自定义事件"}},[e._v("#")]),e._v(" JavaScript自定义事件")]),e._v(" "),n("p",[e._v("DOM也提供了类似上面EventEmitter的API，基本使用：")]),e._v(" "),n("p",[e._v('//1、创建事件\nvar myEvent = new Event("myEvent");')]),e._v(" "),n("p",[e._v('//2、注册事件监听器\nelem.addEventListener("myEvent",function(e){')]),e._v(" "),n("p",[e._v("})")]),e._v(" "),n("p",[e._v("//3、触发事件\nelem.dispatchEvent(myEvent);\nLast Updated: 8/4/2019, 9:33:54 PM\n← 手动实现call、apply、bind 防抖 →")])])}),[],!1,null,null,null);t.default=r.exports}}]);