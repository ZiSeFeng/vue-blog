(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{411:function(v,_,l){"use strict";l.r(_);var i=l(27),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h3",{attrs:{id:"二叉树"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[v._v("#")]),v._v(" 二叉树")]),v._v(" "),l("ul",[l("li",[v._v("二叉树的基本操作 ⭐⭐")]),v._v(" "),l("li",[v._v("二叉树的中序遍历 ⭐⭐")]),v._v(" "),l("li",[v._v("二叉树的前序遍历 ⭐⭐")]),v._v(" "),l("li",[v._v("二叉树的后序遍历 ⭐⭐")]),v._v(" "),l("li",[v._v("重建二叉树 ⭐⭐")]),v._v(" "),l("li",[v._v("求二叉树的遍历 ⭐⭐")]),v._v(" "),l("li",[v._v("对称的二叉树 ⭐⭐")]),v._v(" "),l("li",[v._v("二叉树的镜像 ⭐⭐")]),v._v(" "),l("li",[v._v("二叉搜索树的第 k 个节点 ⭐⭐")]),v._v(" "),l("li",[v._v("二叉搜索树的后序遍历 ⭐⭐")]),v._v(" "),l("li",[v._v("二叉树的最大深度 ⭐⭐")]),v._v(" "),l("li",[v._v("二叉树的最小深度 ⭐⭐")]),v._v(" "),l("li",[v._v("平衡二叉树 ⭐⭐")]),v._v(" "),l("li",[v._v("不分行从上到下打印二叉树 ⭐⭐")]),v._v(" "),l("li",[v._v("把二叉树打印成多行 ⭐⭐")]),v._v(" "),l("li",[v._v("二叉树中和为某一值的路径 ⭐⭐⭐")]),v._v(" "),l("li",[v._v("二叉搜索树与双向链表 ⭐⭐⭐")]),v._v(" "),l("li",[v._v("按之字形顺序打印二叉树 ⭐⭐⭐")]),v._v(" "),l("li",[v._v("序列化二叉树 ⭐⭐⭐")]),v._v(" "),l("li",[v._v("二叉树的下一个节点 ⭐⭐⭐")]),v._v(" "),l("li",[v._v("树的子结构 ⭐⭐⭐")])]),v._v(" "),l("h3",{attrs:{id:"链表"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),l("ul",[l("li",[v._v("删除链表中的节点 or 重复的节点 ⭐⭐")]),v._v(" "),l("li",[v._v("从尾到头打印链表 ⭐⭐")]),v._v(" "),l("li",[v._v("链表倒数第 k 个节点 ⭐⭐")]),v._v(" "),l("li",[v._v("反转链表 ⭐⭐")]),v._v(" "),l("li",[v._v("复杂链表的复制 ⭐⭐")]),v._v(" "),l("li",[v._v("两个链表的第一个公共节点 ⭐⭐")]),v._v(" "),l("li",[v._v("圈圈中最后剩下的数字 ⭐⭐")]),v._v(" "),l("li",[v._v("链表中环的入口节点 ⭐⭐⭐")])]),v._v(" "),l("h3",{attrs:{id:"字符串"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#字符串"}},[v._v("#")]),v._v(" 字符串")]),v._v(" "),l("ul",[l("li",[v._v("替换空格 ⭐⭐")]),v._v(" "),l("li",[v._v("表示数值的字符串 ⭐⭐")]),v._v(" "),l("li",[v._v("字符流中第一个不重复的字符 ⭐⭐")]),v._v(" "),l("li",[v._v("字符串的排列 ⭐⭐")]),v._v(" "),l("li",[v._v("字符串翻转 ⭐⭐")]),v._v(" "),l("li",[v._v("正则表达式匹配 ⭐⭐⭐")])]),v._v(" "),l("h3",{attrs:{id:"栈和队列"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#栈和队列"}},[v._v("#")]),v._v(" 栈和队列")]),v._v(" "),l("ul",[l("li",[v._v("用两个栈实现队列 ⭐⭐")]),v._v(" "),l("li",[v._v("包含 min 函数的栈 ⭐⭐")]),v._v(" "),l("li",[v._v("栈的压入弹出序列 ⭐⭐")]),v._v(" "),l("li",[v._v("滑动窗口的最大值 ⭐⭐⭐")])]),v._v(" "),l("h3",{attrs:{id:"数组"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[v._v("#")]),v._v(" 数组")]),v._v(" "),l("ul",[l("li",[v._v("调整数组顺序使奇数位于偶数前面 ⭐⭐")]),v._v(" "),l("li",[v._v("在排序数组中查找数字 ⭐⭐")]),v._v(" "),l("li",[v._v("数组中出现次数超过数组长度一半的数字 ⭐⭐")]),v._v(" "),l("li",[v._v("连续子数组的最大和 ⭐⭐")]),v._v(" "),l("li",[v._v("把数组排成最小的数 ⭐⭐")]),v._v(" "),l("li",[v._v("第一个只出现一次的字符 ⭐⭐")]),v._v(" "),l("li",[v._v("扑克牌顺子 ⭐⭐")]),v._v(" "),l("li",[v._v("和为 S 的两个数字 ⭐⭐")]),v._v(" "),l("li",[v._v("两数之和 ⭐⭐")]),v._v(" "),l("li",[v._v("三数之和 ⭐⭐⭐")]),v._v(" "),l("li",[v._v("四数之和 ⭐⭐⭐")]),v._v(" "),l("li",[v._v("和为 S 的连续正整数序列 ⭐⭐⭐")]),v._v(" "),l("li",[v._v("构建乘积数组 ⭐⭐⭐")]),v._v(" "),l("li",[v._v("顺时针打印矩阵 ⭐⭐⭐")]),v._v(" "),l("li",[v._v("数组中的逆序对 ⭐⭐⭐")])]),v._v(" "),l("h3",{attrs:{id:"堆"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),l("ul",[l("li",[v._v("堆的基本操作 ⭐⭐⭐")]),v._v(" "),l("li",[v._v("数据流中的中位数 ⭐⭐⭐")]),v._v(" "),l("li",[v._v("最小的 k 个数 ⭐⭐⭐")])])])}),[],!1,null,null,null);_.default=t.exports}}]);