---
title: vue知识点
date: 2019-11-01
---

### 1.v-if、v-show、v-html 的原理是什么，它是如何工作的

v-if：当隐藏结构时改结构会直接从整个 dom 树中移除；watcher 监听数据变化，然后，render 函数生成 VNode 队形，patch 方法对比新旧 VNode、DOM Diff 算法修改真正的 DOM 元素 <br>
v-show：当隐藏结构时是在该结构的 style 中加上 display:none，结构依然保留。

#### 2.Vue 中的 computed 和 watch 的区别在哪里

watch：

- 监听一个实例上的变量的变化，可以接受 2 个参数(newValue, oldValue)，即变化的最新值和上一次的旧值。

computedd：

- 计算属性，即示例上的数据不改变会有缓存，当下一次遇到的属性如果之前使用过，就会把缓存中的值放上去。可以是 data 或者 props，都可以作为计算属性函数的依赖值。
- computed 内部实现了一个惰性的 watcher，在实例化的时候不会去求值，其内部通过 diety 属性标记计算属性是否需要重新求值。当 computed 依赖的任一状态（不一定 return 中的）发生变化，都会通知这个惰性 watcher，让它把 dirty 属性设置为 true。所以，当再次读取这个计算属性的时候，就会重新去求值。
- computed 本身是通过代理的方式代理到组件实例上的，所以读取计算属性的时候，执行的是一个内部的 getter，而不是用户定义的方法。

### 4.前端性能的瓶颈

chrome 的 perfermance、devtools，性能监体系

### 5.手写二进制转 base64

[二进制流图片转 base64 或 blob 地址](https://blackstar.coding.me/2018-08-23-arraybuffer-to-base64orblob.html)

```js
// base 64
let imgBase64 =
  "data:image/jpeg;base64," +
  btoa(String.fromCharCode(...new Uint8Array(response.data)));

// blob
var blob = new Blob([response.data], { type: "image/jpeg" });
var imgBlob = URL.createObjectURL(blob);
```

### 6.将'10000000000'形式的字符串，以每 3 位进行分隔展示'10.000.000.000',多种实现方式

```js
// 德国以 . 分割金钱, 转到德国当地格式化方案即可
1）10000000000..toLocaleString('de-DE')

// 寻找字符空隙加.
2) '10000000000'.replace(/\B(?=(\d{3})+(?!\d))/g, '.')

// 寻找数字并在其后面加 .
3) '10000000000'.replace(/(\d)(?=(\d{3})+\b)/g, '$1.')

4）'10000000000'.replace(/\B(?=(\d{3})+\b)/g, '.')

5）'10000000000'.replace(/(\d)(?=(\d{3})+$)/g,'$1,')

6）'10000000000'.replace(/(?=(?!^)(\d{3})+$)/g, ',')
```

### 7.求多个数组之间的交集

```js
// 1
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);
let intersect = new Set([...a].filter(x => b.has(x)));

// 2
const arr1 = [1, 2, 3];
const arr2 = [3, 4, 5];
const arr3 = [3, 6, 7];
const handle = (...arr) => {
  return arr.reduce((rst, ele, i) => {
    return rst.filter(item => ele.includes(item));
  });
};

handle(arr1, arr2, arr3);
```

### 8.为什么 HTTP1.1 不能实现多路复用

HTTP1.x 是序列和阻塞机制

HTTP2.0 是多工复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一一对应，这样就避免了“队头堵塞”

- 举例来说，在一个 TCP 连接里面，服务器同时受到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A 请求已经处理好的部分，接着回应 B 请求，完成后，再发送 A 请求剩下的部分。
- 旧的 http1.1 是会等 A 请求完全处理完后在处理 B 请求，会阻塞
- 另：http1.1 已经实现了管道机制：即在同一个 TCP 连接里面，客户端可以同时发送多个请求。http1.0 并做不动，所以效率很低

HTTP/1.x 有个问题叫队头阻塞，即一个连接同时只能有效地承载一个请求。<br/>
HTTP/1.1 试过用流水线来解决这个问题，但是效果并不理想(数据量较大或者速度较慢的响应，仍然会阻碍排在后面的响应)。此外，由于网络中介和服务器都不能很好的支持流水线技术，导致部署起来困难重重。
客户端被迫使用一些启发式的算法（基本靠猜）来决定哪些连接来承载哪些请求；由于通常一个页面加载资源的连接需求，往往超过了可用连接资源的 10 倍，这对性能产生极大的负面影响，后果经常是引起了风暴式的阻塞。<br/>
而多路复用则能很好的解决这些问题，因为它能同时处理多个消息的请求和响应；甚至可以在传输过程中将一个消息跟另外一个糅合在一起。
所以客户端只需要一个连接就能加载一个完整的页面。<br/>
http2.0 也存在队头阻塞问题，如果造成队头阻塞，问题可能比 http1.1 还严重，因为只有一个 tcp 连接，后续的传输都要等前面，http1.1 多个 tcp 连接，阻塞一个，其他的还可以正常跑
在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1 了。因为 TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP 连接中的所有请求（如下图）。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。

### 9.谈一谈 nextTick 的原理

:::tip 异步说明
Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新
:::

:::tip 事件循环说明
Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新
:::

:::tip
Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并之执行实际（已去重）的工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageControl，如果执行环境不支持，会采用 setTimeout(fn, 0)代替
:::

在 vue 的双向绑定-响应式系统中，会经过"setter-Dep-Watcher-patch->视图"
